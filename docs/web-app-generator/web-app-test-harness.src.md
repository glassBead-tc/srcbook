<!-- srcbook:{"language":"typescript"} -->

# Web App Generator Test Harness

This notebook provides utilities for testing web applications generated by the Srcbook Web App Generator. It helps ensure that generated applications are functional and follow best practices.

## Test Harness Setup

First, let's set up our dependencies:

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "glob": "^10.3.10",
    "chalk": "^5.3.0",
    "zod": "^3.22.4",
    "puppeteer": "^21.0.0",
    "jest": "^29.0.0",
    "@testing-library/jest-dom": "^6.0.0"
  }
}
```

### Test Runner Types

###### types.ts

```typescript
interface TestResult {
  appPath: string;
  components: ComponentResult[];
  e2eTests: E2ETestResult[];
  success: boolean;
  error?: string;
}

interface ComponentResult {
  name: string;
  type: 'component' | 'page' | 'layout';
  renderTests: boolean;
  interactionTests: boolean;
  success: boolean;
  error?: string;
}

interface E2ETestResult {
  name: string;
  steps: TestStep[];
  success: boolean;
  error?: string;
  screenshots?: string[];
}

interface TestStep {
  description: string;
  success: boolean;
  error?: string;
}

interface TestSummary {
  totalApps: number;
  passedApps: number;
  failedApps: number;
  results: TestResult[];
}
```

### App Discovery

###### app-loader.ts

```typescript
import { glob } from 'glob';
import { readFile } from 'fs/promises';
import { join } from 'path';

export async function findWebApps(dir: string): Promise<string[]> {
  const pattern = join(dir, '**/package.json');
  const files = await glob(pattern);
  return files.map(f => join(f, '..'));
}

export async function loadAppConfig(path: string): Promise<any> {
  const configPath = join(path, 'package.json');
  const content = await readFile(configPath, 'utf-8');
  return JSON.parse(content);
}
```

### Test Runner

###### test-runner.ts

```typescript
import chalk from 'chalk';
import puppeteer from 'puppeteer';
import type { TestResult, ComponentResult, E2ETestResult, TestSummary } from './types.ts';
import { findWebApps, loadAppConfig } from './app-loader.ts';

export async function runTests(dir: string): Promise<TestSummary> {
  const apps = await findWebApps(dir);
  const results: TestResult[] = [];
  
  for (const app of apps) {
    try {
      const config = await loadAppConfig(app);
      const result = await testWebApp(app, config);
      results.push({
        appPath: app,
        ...result
      });
    } catch (error) {
      results.push({
        appPath: app,
        components: [],
        e2eTests: [],
        success: false,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  
  return summarizeResults(results);
}

async function testWebApp(path: string, config: any): Promise<Omit<TestResult, 'appPath'>> {
  const components = await testComponents(path);
  const e2eTests = await runE2ETests(path);
  
  const success = components.every(c => c.success) && 
                 e2eTests.every(t => t.success);
  
  return {
    components,
    e2eTests,
    success
  };
}

async function testComponents(path: string): Promise<ComponentResult[]> {
  // TODO: Implement component testing logic
  // This would:
  // 1. Find all components
  // 2. Run render tests
  // 3. Run interaction tests
  // 4. Verify accessibility
  return [];
}

async function runE2ETests(path: string): Promise<E2ETestResult[]> {
  const browser = await puppeteer.launch();
  try {
    // TODO: Implement E2E testing logic
    // This would:
    // 1. Start the dev server
    // 2. Run user flows
    // 3. Take screenshots
    // 4. Verify functionality
    return [];
  } finally {
    await browser.close();
  }
}

function summarizeResults(results: TestResult[]): TestSummary {
  const totalApps = results.length;
  const passedApps = results.filter(r => r.success).length;
  const failedApps = totalApps - passedApps;
  
  return {
    totalApps,
    passedApps,
    failedApps,
    results
  };
}
```

### Results Reporter

###### reporter.ts

```typescript
import chalk from 'chalk';
import type { TestSummary, TestResult, ComponentResult, E2ETestResult } from './types.ts';

export function reportResults(summary: TestSummary): void {
  console.log('\nWeb App Test Results:');
  console.log('====================\n');
  
  console.log(`Total Apps: ${summary.totalApps}`);
  console.log(`Passed: ${chalk.green(summary.passedApps)}`);
  console.log(`Failed: ${chalk.red(summary.failedApps)}\n`);
  
  for (const result of summary.results) {
    reportAppResult(result);
  }
}

function reportAppResult(result: TestResult): void {
  const status = result.success ? chalk.green('PASS') : chalk.red('FAIL');
  console.log(`${status} ${result.appPath}`);
  
  if (!result.success && result.error) {
    console.log(chalk.red(`  Error: ${result.error}`));
  }
  
  console.log('\n  Components:');
  for (const component of result.components) {
    reportComponentResult(component);
  }
  
  console.log('\n  E2E Tests:');
  for (const test of result.e2eTests) {
    reportE2EResult(test);
  }
  
  console.log('');
}

function reportComponentResult(component: ComponentResult): void {
  const status = component.success ? chalk.green('✓') : chalk.red('✗');
  console.log(`    ${status} ${component.type} ${component.name}`);
  if (!component.success && component.error) {
    console.log(chalk.red(`      ${component.error}`));
  }
}

function reportE2EResult(test: E2ETestResult): void {
  const status = test.success ? chalk.green('✓') : chalk.red('✗');
  console.log(`    ${status} ${test.name}`);
  
  if (!test.success) {
    for (const step of test.steps) {
      if (!step.success) {
        console.log(chalk.red(`      × ${step.description}`));
        if (step.error) {
          console.log(chalk.red(`        ${step.error}`));
        }
      }
    }
  }
}
```

### Test Runner Usage

###### run-tests.ts

```typescript
import { runTests } from './test-runner.ts';
import { reportResults } from './reporter.ts';

async function main() {
  try {
    const summary = await runTests('../apps');
    reportResults(summary);
    process.exit(summary.failedApps > 0 ? 1 : 0);
  } catch (error) {
    console.error('Test runner failed:', error);
    process.exit(1);
  }
}

main();
```

## Running the Tests

To run tests on all generated web applications:

1. Install dependencies:
```bash
npm install
```

2. Run the test runner:
```bash
npx tsx run-tests.ts
```

## Test Categories

The test harness verifies several aspects of each web application:

1. **Component Testing**
   - Render testing
   - Interaction testing
   - Accessibility testing
   - Style verification

2. **End-to-End Testing**
   - User flows
   - Navigation
   - Form submission
   - API integration
   - Error handling

3. **Performance Testing**
   - Load time
   - First paint
   - Time to interactive
   - Bundle size

4. **Code Quality**
   - TypeScript compilation
   - ESLint rules
   - Best practices
   - File structure

## Adding Tests

To add tests for a new web application:

1. Generate the application using the Web App Generator
2. Add test cases in the __tests__ directory
3. Add E2E test scenarios
4. Run the test harness
5. Review and fix any issues

## Next Steps

1. Implement the component testing logic in test-runner.ts
2. Add E2E test scenarios for common user flows
3. Set up continuous integration
4. Add performance benchmarking
5. Implement accessibility testing

This test harness will help ensure that all generated web applications are functional, performant, and follow best practices.
